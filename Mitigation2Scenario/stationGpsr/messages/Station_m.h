//
// Generated file, do not edit! Created by opp_msgtool 6.0 from stationGpsr/messages/Station.msg.
//

#ifndef __INET_STATION_M_H
#define __INET_STATION_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace inet {

class StationNotice;
class verifyPositionRequest;
class verifyPositionResponse;
class StationNoticeResponse;
class NeighborVerificationRequest;
class PositionRequest;
class PositionResponse;
class S2SPositionRequest;
class S2SPositionResponse;
class SimpleMessage;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TlvOptions_m.h" // import inet.common.TlvOptions

#include "inet/common/geometry/Geometry_m.h" // import inet.common.geometry.Geometry

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address

// cplusplus {{
    
#include "inet/routing/gpsr/GpsrDefs.h"
// }}


namespace inet {

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:17</tt> by opp_msgtool.
 * <pre>
 * //MODIFICA VA AGGIUNTO IL CAMPO NONCE E LA LISTA DEGLI INDIRIZZI DEI SUOI VICINI:
 * class StationNotice extends FieldsChunk
 * {
 *     L3Address source;//modifica
 *     string sourceModuleName; //modifica
 *     Coord position;
 *     bool deregister;
 *     //uint64_t nonce; //modifica
 *     L3Address addressList[];
 *     double distanceList[];
 *     Coord positionList[];
 * }
 * </pre>
 */
class StationNotice : public ::inet::FieldsChunk
{
  protected:
    L3Address source;
    ::omnetpp::opp_string sourceModuleName;
    Coord position;
    bool deregister = false;
    L3Address *addressList = nullptr;
    size_t addressList_arraysize = 0;
    double *distanceList = nullptr;
    size_t distanceList_arraysize = 0;
    Coord *positionList = nullptr;
    size_t positionList_arraysize = 0;

  private:
    void copy(const StationNotice& other);

  protected:
    bool operator==(const StationNotice&) = delete;

  public:
    StationNotice();
    StationNotice(const StationNotice& other);
    virtual ~StationNotice();
    StationNotice& operator=(const StationNotice& other);
    virtual StationNotice *dup() const override {return new StationNotice(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSource() const;
    virtual L3Address& getSourceForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<StationNotice*>(this)->getSource());}
    virtual void setSource(const L3Address& source);

    virtual const char * getSourceModuleName() const;
    virtual void setSourceModuleName(const char * sourceModuleName);

    virtual const Coord& getPosition() const;
    virtual Coord& getPositionForUpdate() { handleChange();return const_cast<Coord&>(const_cast<StationNotice*>(this)->getPosition());}
    virtual void setPosition(const Coord& position);

    virtual bool getDeregister() const;
    virtual void setDeregister(bool deregister);

    virtual void setAddressListArraySize(size_t size);
    virtual size_t getAddressListArraySize() const;
    virtual const L3Address& getAddressList(size_t k) const;
    virtual L3Address& getAddressListForUpdate(size_t k) { handleChange();return const_cast<L3Address&>(const_cast<StationNotice*>(this)->getAddressList(k));}
    virtual void setAddressList(size_t k, const L3Address& addressList);
    virtual void insertAddressList(size_t k, const L3Address& addressList);
    [[deprecated]] void insertAddressList(const L3Address& addressList) {appendAddressList(addressList);}
    virtual void appendAddressList(const L3Address& addressList);
    virtual void eraseAddressList(size_t k);

    virtual void setDistanceListArraySize(size_t size);
    virtual size_t getDistanceListArraySize() const;
    virtual double getDistanceList(size_t k) const;
    virtual void setDistanceList(size_t k, double distanceList);
    virtual void insertDistanceList(size_t k, double distanceList);
    [[deprecated]] void insertDistanceList(double distanceList) {appendDistanceList(distanceList);}
    virtual void appendDistanceList(double distanceList);
    virtual void eraseDistanceList(size_t k);

    virtual void setPositionListArraySize(size_t size);
    virtual size_t getPositionListArraySize() const;
    virtual const Coord& getPositionList(size_t k) const;
    virtual Coord& getPositionListForUpdate(size_t k) { handleChange();return const_cast<Coord&>(const_cast<StationNotice*>(this)->getPositionList(k));}
    virtual void setPositionList(size_t k, const Coord& positionList);
    virtual void insertPositionList(size_t k, const Coord& positionList);
    [[deprecated]] void insertPositionList(const Coord& positionList) {appendPositionList(positionList);}
    virtual void appendPositionList(const Coord& positionList);
    virtual void erasePositionList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const StationNotice& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, StationNotice& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:29</tt> by opp_msgtool.
 * <pre>
 * class verifyPositionRequest extends FieldsChunk
 * {
 *     L3Address source;
 *     L3Address addressToVerify;
 * }
 * </pre>
 */
class verifyPositionRequest : public ::inet::FieldsChunk
{
  protected:
    L3Address source;
    L3Address addressToVerify;

  private:
    void copy(const verifyPositionRequest& other);

  protected:
    bool operator==(const verifyPositionRequest&) = delete;

  public:
    verifyPositionRequest();
    verifyPositionRequest(const verifyPositionRequest& other);
    virtual ~verifyPositionRequest();
    verifyPositionRequest& operator=(const verifyPositionRequest& other);
    virtual verifyPositionRequest *dup() const override {return new verifyPositionRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSource() const;
    virtual L3Address& getSourceForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<verifyPositionRequest*>(this)->getSource());}
    virtual void setSource(const L3Address& source);

    virtual const L3Address& getAddressToVerify() const;
    virtual L3Address& getAddressToVerifyForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<verifyPositionRequest*>(this)->getAddressToVerify());}
    virtual void setAddressToVerify(const L3Address& addressToVerify);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const verifyPositionRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, verifyPositionRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:34</tt> by opp_msgtool.
 * <pre>
 * class verifyPositionResponse extends FieldsChunk
 * {
 *     L3Address source;
 *     L3Address AddressToVerify;
 *     int status; //0 non è presente 1 è presente
 * }
 * 
 * 
 * 
 * // MODIFICA AGGIUNTA MESSAGGI RISPOSTA STAZIONE STATIONNOTICE
 * </pre>
 */
class verifyPositionResponse : public ::inet::FieldsChunk
{
  protected:
    L3Address source;
    L3Address AddressToVerify;
    int status = 0;

  private:
    void copy(const verifyPositionResponse& other);

  protected:
    bool operator==(const verifyPositionResponse&) = delete;

  public:
    verifyPositionResponse();
    verifyPositionResponse(const verifyPositionResponse& other);
    virtual ~verifyPositionResponse();
    verifyPositionResponse& operator=(const verifyPositionResponse& other);
    virtual verifyPositionResponse *dup() const override {return new verifyPositionResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSource() const;
    virtual L3Address& getSourceForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<verifyPositionResponse*>(this)->getSource());}
    virtual void setSource(const L3Address& source);

    virtual const L3Address& getAddressToVerify() const;
    virtual L3Address& getAddressToVerifyForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<verifyPositionResponse*>(this)->getAddressToVerify());}
    virtual void setAddressToVerify(const L3Address& AddressToVerify);

    virtual int getStatus() const;
    virtual void setStatus(int status);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const verifyPositionResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, verifyPositionResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:45</tt> by opp_msgtool.
 * <pre>
 * class StationNoticeResponse extends FieldsChunk
 * {
 *     string c; // CIFRATURA
 *     double x;
 *     double y;
 *     double z;
 *     uint64_t nonce; //NONCE
 * }
 * </pre>
 */
class StationNoticeResponse : public ::inet::FieldsChunk
{
  protected:
    ::omnetpp::opp_string c;
    double x = 0;
    double y = 0;
    double z = 0;
    uint64_t nonce = 0;

  private:
    void copy(const StationNoticeResponse& other);

  protected:
    bool operator==(const StationNoticeResponse&) = delete;

  public:
    StationNoticeResponse();
    StationNoticeResponse(const StationNoticeResponse& other);
    virtual ~StationNoticeResponse();
    StationNoticeResponse& operator=(const StationNoticeResponse& other);
    virtual StationNoticeResponse *dup() const override {return new StationNoticeResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const char * getC() const;
    virtual void setC(const char * c);

    virtual double getX() const;
    virtual void setX(double x);

    virtual double getY() const;
    virtual void setY(double y);

    virtual double getZ() const;
    virtual void setZ(double z);

    virtual uint64_t getNonce() const;
    virtual void setNonce(uint64_t nonce);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const StationNoticeResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, StationNoticeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:53</tt> by opp_msgtool.
 * <pre>
 * class NeighborVerificationRequest extends FieldsChunk
 * {
 *     L3Address target; // Indirizzo del nodo da verificare
 * }
 * </pre>
 */
class NeighborVerificationRequest : public ::inet::FieldsChunk
{
  protected:
    L3Address target;

  private:
    void copy(const NeighborVerificationRequest& other);

  protected:
    bool operator==(const NeighborVerificationRequest&) = delete;

  public:
    NeighborVerificationRequest();
    NeighborVerificationRequest(const NeighborVerificationRequest& other);
    virtual ~NeighborVerificationRequest();
    NeighborVerificationRequest& operator=(const NeighborVerificationRequest& other);
    virtual NeighborVerificationRequest *dup() const override {return new NeighborVerificationRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getTarget() const;
    virtual L3Address& getTargetForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborVerificationRequest*>(this)->getTarget());}
    virtual void setTarget(const L3Address& target);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NeighborVerificationRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NeighborVerificationRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:58</tt> by opp_msgtool.
 * <pre>
 * class PositionRequest extends FieldsChunk
 * {
 *     L3Address source;
 *     string sourceModuleName;
 *     L3Address address;
 * }
 * </pre>
 */
class PositionRequest : public ::inet::FieldsChunk
{
  protected:
    L3Address source;
    ::omnetpp::opp_string sourceModuleName;
    L3Address address;

  private:
    void copy(const PositionRequest& other);

  protected:
    bool operator==(const PositionRequest&) = delete;

  public:
    PositionRequest();
    PositionRequest(const PositionRequest& other);
    virtual ~PositionRequest();
    PositionRequest& operator=(const PositionRequest& other);
    virtual PositionRequest *dup() const override {return new PositionRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSource() const;
    virtual L3Address& getSourceForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<PositionRequest*>(this)->getSource());}
    virtual void setSource(const L3Address& source);

    virtual const char * getSourceModuleName() const;
    virtual void setSourceModuleName(const char * sourceModuleName);

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<PositionRequest*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PositionRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PositionRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:66</tt> by opp_msgtool.
 * <pre>
 * // vedere se eliminare timestamp
 * class PositionResponse extends FieldsChunk
 * {
 *     bool setted;
 *     L3Address address;
 *     Coord position;
 *     simtime_t time;
 * }
 * </pre>
 */
class PositionResponse : public ::inet::FieldsChunk
{
  protected:
    bool setted = false;
    L3Address address;
    Coord position;
    ::omnetpp::simtime_t time = SIMTIME_ZERO;

  private:
    void copy(const PositionResponse& other);

  protected:
    bool operator==(const PositionResponse&) = delete;

  public:
    PositionResponse();
    PositionResponse(const PositionResponse& other);
    virtual ~PositionResponse();
    PositionResponse& operator=(const PositionResponse& other);
    virtual PositionResponse *dup() const override {return new PositionResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getSetted() const;
    virtual void setSetted(bool setted);

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<PositionResponse*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);

    virtual const Coord& getPosition() const;
    virtual Coord& getPositionForUpdate() { handleChange();return const_cast<Coord&>(const_cast<PositionResponse*>(this)->getPosition());}
    virtual void setPosition(const Coord& position);

    virtual ::omnetpp::simtime_t getTime() const;
    virtual void setTime(::omnetpp::simtime_t time);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PositionResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PositionResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:74</tt> by opp_msgtool.
 * <pre>
 * class S2SPositionRequest extends FieldsChunk
 * {
 *     L3Address applicant;
 *     string applicantModuleName;
 *     L3Address source;
 *     string sourceModuleName;
 *     L3Address address;
 * }
 * </pre>
 */
class S2SPositionRequest : public ::inet::FieldsChunk
{
  protected:
    L3Address applicant;
    ::omnetpp::opp_string applicantModuleName;
    L3Address source;
    ::omnetpp::opp_string sourceModuleName;
    L3Address address;

  private:
    void copy(const S2SPositionRequest& other);

  protected:
    bool operator==(const S2SPositionRequest&) = delete;

  public:
    S2SPositionRequest();
    S2SPositionRequest(const S2SPositionRequest& other);
    virtual ~S2SPositionRequest();
    S2SPositionRequest& operator=(const S2SPositionRequest& other);
    virtual S2SPositionRequest *dup() const override {return new S2SPositionRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getApplicant() const;
    virtual L3Address& getApplicantForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<S2SPositionRequest*>(this)->getApplicant());}
    virtual void setApplicant(const L3Address& applicant);

    virtual const char * getApplicantModuleName() const;
    virtual void setApplicantModuleName(const char * applicantModuleName);

    virtual const L3Address& getSource() const;
    virtual L3Address& getSourceForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<S2SPositionRequest*>(this)->getSource());}
    virtual void setSource(const L3Address& source);

    virtual const char * getSourceModuleName() const;
    virtual void setSourceModuleName(const char * sourceModuleName);

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<S2SPositionRequest*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const S2SPositionRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, S2SPositionRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:84</tt> by opp_msgtool.
 * <pre>
 * // vedere se eliminare timestamp
 * class S2SPositionResponse extends FieldsChunk
 * {
 *     L3Address applicant;
 *     string applicantModuleName;
 *     bool setted;
 *     L3Address address;
 *     Coord position;
 *     simtime_t time;
 * }
 * </pre>
 */
class S2SPositionResponse : public ::inet::FieldsChunk
{
  protected:
    L3Address applicant;
    ::omnetpp::opp_string applicantModuleName;
    bool setted = false;
    L3Address address;
    Coord position;
    ::omnetpp::simtime_t time = SIMTIME_ZERO;

  private:
    void copy(const S2SPositionResponse& other);

  protected:
    bool operator==(const S2SPositionResponse&) = delete;

  public:
    S2SPositionResponse();
    S2SPositionResponse(const S2SPositionResponse& other);
    virtual ~S2SPositionResponse();
    S2SPositionResponse& operator=(const S2SPositionResponse& other);
    virtual S2SPositionResponse *dup() const override {return new S2SPositionResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getApplicant() const;
    virtual L3Address& getApplicantForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<S2SPositionResponse*>(this)->getApplicant());}
    virtual void setApplicant(const L3Address& applicant);

    virtual const char * getApplicantModuleName() const;
    virtual void setApplicantModuleName(const char * applicantModuleName);

    virtual bool getSetted() const;
    virtual void setSetted(bool setted);

    virtual const L3Address& getAddress() const;
    virtual L3Address& getAddressForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<S2SPositionResponse*>(this)->getAddress());}
    virtual void setAddress(const L3Address& address);

    virtual const Coord& getPosition() const;
    virtual Coord& getPositionForUpdate() { handleChange();return const_cast<Coord&>(const_cast<S2SPositionResponse*>(this)->getPosition());}
    virtual void setPosition(const Coord& position);

    virtual ::omnetpp::simtime_t getTime() const;
    virtual void setTime(::omnetpp::simtime_t time);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const S2SPositionResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, S2SPositionResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>stationGpsr/messages/Station.msg:94</tt> by opp_msgtool.
 * <pre>
 * class SimpleMessage extends FieldsChunk
 * {
 *     string payload;
 * }
 * </pre>
 */
class SimpleMessage : public ::inet::FieldsChunk
{
  protected:
    ::omnetpp::opp_string payload;

  private:
    void copy(const SimpleMessage& other);

  protected:
    bool operator==(const SimpleMessage&) = delete;

  public:
    SimpleMessage();
    SimpleMessage(const SimpleMessage& other);
    virtual ~SimpleMessage();
    SimpleMessage& operator=(const SimpleMessage& other);
    virtual SimpleMessage *dup() const override {return new SimpleMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const char * getPayload() const;
    virtual void setPayload(const char * payload);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SimpleMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SimpleMessage& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

template<> inline inet::StationNotice *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::StationNotice*>(ptr.get<cObject>()); }
template<> inline inet::verifyPositionRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::verifyPositionRequest*>(ptr.get<cObject>()); }
template<> inline inet::verifyPositionResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::verifyPositionResponse*>(ptr.get<cObject>()); }
template<> inline inet::StationNoticeResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::StationNoticeResponse*>(ptr.get<cObject>()); }
template<> inline inet::NeighborVerificationRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::NeighborVerificationRequest*>(ptr.get<cObject>()); }
template<> inline inet::PositionRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::PositionRequest*>(ptr.get<cObject>()); }
template<> inline inet::PositionResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::PositionResponse*>(ptr.get<cObject>()); }
template<> inline inet::S2SPositionRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::S2SPositionRequest*>(ptr.get<cObject>()); }
template<> inline inet::S2SPositionResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::S2SPositionResponse*>(ptr.get<cObject>()); }
template<> inline inet::SimpleMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::SimpleMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_STATION_M_H

